---
title: "Regu³y Sekwencyjne dla pacjentów chorych na cukrzycê."
author: "Ludwik Przyrowski, Adam Kolipiñski"
date: "7 maja 2017"
output:
  html_document: default
  pdf_document: default

---
```{r setup, include=FALSE}
#knitr::opts_chunk$set(cache=TRUE)
```

## Opis i specyfika zadania

W obliczeñ zostana u¿yte nastêpujace boblioteki:
```{R, message=F}
library(arules)
library(arulesSequences)
library(ggplot2)
library(dplyr)
```
## Eksploracja danych wejœciowych
Do zadania pos³u¿y³y dane wejœciowe ze zbioru UCI Machine Learning Repository (https://archive.ics.uci.edu/ml/datasets/Diabetes) opracowane pocz¹tkowo poprzez Michael Kahn, MD, PhD, Washington University, St. Louis, MO a nastêpnie przetworzone w Politechnice Warszawskiej na potrzeby laboratorium.
```{R, message=FALSE, warning=FALSE}
download.file('http://staff.ii.pw.edu.pl/~gprotazi/dydaktyka/dane/diab_trans.data', destfile = 'data/diab_trans.data')
diab.df <- read.csv("data/diab_trans.data", header=TRUE, stringsAsFactors = FALSE)
```
Dane zawieraj¹ codzienne czynnoœci dla 70 pacjentów chorych na cukrzycê.
```{R, }
head(diab.df)
```
Dla lepszego zrozumienia danych zmiennej 'code' zosta³y przypisane opisy zdarzeñ
```{R, message=FALSE}
diab.df$code_id = as.numeric(substring(diab.df$code, 4,5))
description.df <- read.csv('data/description.txt', header=TRUE)

input.df <- inner_join(diab.df,description.df)
head(select(input.df, code_id, description_PL))

```

Tylko niektóre typy wydarzeñ maj¹ znacz¹c¹ wartoœæ zmiennej 'value', w reszcie przypisana jest cyfra 0
```{R, message=F}

to_chunk.df = input.df %>% 
  group_by(code_id) %>%
  distinct(value) %>%
  summarise(count=n()) %>%
  filter(count>1)
to_chunk.df$measure = TRUE 

base.df <- left_join(input.df, to_chunk.df)
dawka = c(33, 34, 35)
base.df <- base.df %>% mutate(type = ifelse(measure==T, ifelse(code_id %in% dawka, 'dawka', 'pomiar'), 'wydarzenie'))
to_chunk_temp.df = inner_join(description.df, to_chunk.df)
as.vector(to_chunk_temp.df$description_PL)


```

## Podzielenie mierzalnych danych na kategorie
```{R, message=F, warning=F}
to_hist_pomiar.df <- base.df %>% na.omit() %>% filter(measure==TRUE, type=='pomiar')
ggplot(to_hist_pomiar.df, aes(x=value, fill=description_PL))+geom_histogram()
to_hist_dawka.df <- base.df %>% na.omit() %>% filter(measure==TRUE, type=='dawka')
ggplot(to_hist_dawka.df, aes(x=value, fill=description_PL))+geom_histogram(binwidth = 1)+scale_x_continuous(limits = c(2,40))
```

Podzia³ wartoœci dawek i pomiaru krwi zosta³ wykonany na podstawie 20tego i 80tego precentyla. Wartoœci ponmiêdzy uznane zosta³y jako 'normalne', poni¿ej - 'niskie' a powy¿ej- 'wysokie'. Poni¿ej przyk³ad dla pomiaru glukozy we krwi przed kolacj¹:
```{R,message=F, warning=F}
to_hist.df <- base.df %>% na.omit() %>% filter(measure==TRUE, code_id==62)

q <- quantile(to_hist.df$value, c(0.20, 0.80))

ggplot(to_hist.df, aes(x=value))+geom_histogram()+geom_vline(xintercept = c(q[1], q[2]))
```

podzia³ zosta³ wykonany dla wszystkich kategorii które zawieraj¹ dane mierzalne
```{R}
to_divide.df <- base.df %>% na.omit() %>% filter(measure==TRUE)
for_loop <- to_divide.df %>% distinct(code_id)
qa = c()
qb = c()
code = c()

for(i in for_loop$code_id){
  to_divide_tmp.df <- base.df %>% na.omit() %>% filter(measure==TRUE, code_id==i)
  qa = c(qa,  quantile(to_divide_tmp.df$value, c(0.20)))
  qb = c(qb,  quantile(to_divide_tmp.df$value, c(0.80)))
  code = c(code, i)
  
}
df <- data.frame(code,qa,qb)

cluster <- function(code_id, value){

      qa=df[df$code==code_id,"qa"]
      qb=df[df$code==code_id,"qb"]
      if(length(qa)==0 || length(qb)==0 )
        return(NA)

      if(is.na(value))
        return(NA)
      if(is.null(value))
        return(NA)
      
      if(value<qa){
        return('niski')
        }
      else if(value>qb){
        return('wysoki')
        }
      else if(value>=qa & value<=qb){
        return('normalny')
        }
      else{
        return(NA)}
}

base.df$value.level <- mapply(cluster, base.df$code_id, base.df$value)
```
## Po³¹czenie wartoœci zmiennych dla tego samego czasu
Nastêpnie ³¹czone s¹ wartoœci wydarzeñ wraz z ich poziomami gdzie jest to aplikowalne:
```{r}
df <-base.df %>%
  mutate(description = if_else(!is.na(value.level),paste(description_PL,"poziom", value.level), as.character(description_PL)))  %>%
  select(patient_id, time_sek, description)
```
W celu u³atwieñ obliczeniowych nadane zosta³y nowe numery ID do ka¿dego po³¹czonego wydarzenia:
```{r}
new_id <- df %>%arrange(description) %>% distinct(description)
new_id$id <- seq.int(nrow(new_id))

head(new_id)

```
Tak przygotowane dane s¹ gotowe do dalszej analizy:
```{r}
df = inner_join(df, new_id)
head(df)
```

## Wykrywanie wzorców sekwencyjnych

Zapisano data.frame do pliku .csv aby wygodnie wczyta³o siê dane w trybie sekwencyjnym
```{r}
write.table(df[,c(1,2,3)], file = "data/clean_data.csv", row.names=FALSE,col.names=FALSE, sep=",")
```

Wczytano dane w postaci z nowoutworzonego pliku
```{r}
dseq <- read_baskets(con = "data/clean_data.csv", sep =",", info = c("sequenceID","eventID"))
```

Test czy dane zosta³y wczytane poprawnie, przez ponown¹ transformacjê do data.frame
```{r}
frameS =   as(dseq,"data.frame")
head(frameS)
```

Wstêpna analiza otrzymanych sekwencji
liczba mo¿liwych elementów; czêstoœæ zdarzeñ:
```{r}
nitems(dseq)
freqItem = itemFrequency(dseq)
freqItem = sort(freqItem, decreasing = TRUE )
freqItem
head(freqItem,30)
```

Wsparcie objawów hipoglikemii to ~0,11 dlatego zaczniemy rozwa¿ania od wsparcia = 0.1    

Po testach proponujemy nastêpuj¹ce parametry algorytym cspade:    
- support=0.05: wsparcie ustawiamy doœæ nisko, ¿eby "z³apaæ" tak¿e regu³y zwi¹zane z wydarzeniami, które wydarzaj¹ siê rzadko    
- maxsize = 1 wszystkie "koszyki" to jednorazowe zdarzenia, dlatego mo¿na zastosowaæ maxsize=1    
- maxgap = 28800 w tym wypadku interesuj¹ nas zdarzenia, które wystêpuj¹ w zakresie 8 godzin    
- maxlen = 4 zdarzenia w obrêbie max 8 godzin daj¹ ³¹czny zakres objawów w ramach doby, co wydaje siê rozs¹dn¹ granic¹ dla hipoglikemii     
- maxwin - w algorytmie cspade pakietu arulesSequences ma status "disabled", dlatego nie mo¿emy go u¿yæ.    
    
Nastêpnie wyszukamy wzorce czêste i regu³y sekwencyjne
```{r}
parametry = new ("SPparameter",support = 0.05, maxsize = 1, maxgap = 28800, maxlen=4)
wzorce= cspade(dseq, parametry, control = list(verbose = TRUE, tidLists = FALSE, summary= TRUE))
#odkrycie regu³
reguly = ruleInduction(wzorce,confidence = 0.8)
```

Liczba i podgl¹d otrzymanych regu³
```{r}
length(reguly)
inspect(head(reguly,10))
```

Ograniczamy siê do regu³ nas interesuj¹cych - tych które maj¹ "objawy hipoglikemii" po prawej, ale nie po lewej stronie. Sortujemy je wed³ug wielkoœci wspó³czynnika lift. 
```{r}
hipoglik=subset(reguly, !(lhs(reguly) %in% c("\"Objawy hipoglikemii\"")) & rhs(reguly) %in% c("\"Objawy hipoglikemii\""))
hipoglik = sort(hipoglik, by = "lift", decreasing=TRUE)
inspect(hipoglik)
```
##Podsumowanie
Otrzymaliœmy 15 wzorcóW sekwencyjnych, które mog¹ pos³u¿yæ do szybkiego wykrycia i zapobie¿enia obajwów hipoglikemii. 
W wiêkszoœci wypadków ostatnim zdarzeniem bezpoœrednio przed wyst¹pieniem objawów by³ pomiar wskazuj¹cy na niski poziom glukozy we krwi, zw³aœzcza "nieokreœlony" - a wiêc wykonany ad hoc - nie zwi¹zany z posi³kiem. Œwiadczy to o tym, ¿e pacjenci byli œwiadomi swojego stanu, ale nie mogli, b¹dŸ nie uda³o im sie hipoglikemii zapobiec.     

Szczególnie interesuj¹c¹ odkryt¹ regu³¹ jest regu³a ostatnia, jako jedyna zwi¹zana z nawykami ¿ywieniowymi.     
  <{"Spo¿ycie posi³ku wiêkszego ni¿ zazwyczaj"},                  
 {"Pomiar zawartoœci glukozy we krwi przed obiadem poziom niski"},    
 {"Pomiar zawartoœci glukozy we krwi przed kolacj¹ poziom niski"}>         
 => <{"Objawy hipoglikemii"}>       
Œwiadczy ona o tym, ¿e zbyt du¿e œniadanie, w po³¹czeniu z utrzymuj¹c¹ siê nisk¹ zawartoœci¹ glukozy we krwi, mo¿e byæ niebezpieczne dla pacjentów! Byæ mo¿e wypada³oby uczuliæ ich na tak¹ mo¿liwoœæ w czasie wywiadu.     